{"ast":null,"code":"var _jsxFileName = \"/home/lorismilloni/Repos/top_trumps/src/components/FilterList.jsx\";\nimport React, { Component } from 'react';\nimport PropTypes from 'prop-types';\nimport Card from './Card'; // Requisito 10, 11 e 12 feitos seguindo o PR do Leonardo Vogel, com o objetivo de treinar a implementação da função e quem sabe deixar o joguinho funcional depois. Obrigada Leo.\n// Obrigada Eduardo Bazler por me ajudar a resolver o conflito no requisito, para passar no teste e não imprimir mais duas listas no meu Tryunfo, precisei remover do App o CardList, que continua comitado para consulta, a exibição anterior da lista que eu tinha criado para passar no requisito 8.\n// Agora só a lista com os filtros é exibida na minha página do Tryunfo.\n\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nexport default class FilterList extends Component {\n  render() {\n    const {\n      cardList,\n      deleteCard,\n      filterName,\n      filterRare,\n      filterTrunfo\n    } = this.props;\n    let filterCards = [...cardList]; // aqui o filtro atualiza o array de cards de acordo com o que foi aplicado, um valor inicial recebe a lista de cartas, para que caso não seja aplicado nenhum filtro, ele exiba todos as cartas;\n    // caso exista alguma coisa no input de filtro por nome, ele executa um filter atualizando o próprio filterCards, adicionando ao novo array apenas aqueles cards que tenham no nome o que foi passado no input;\n\n    if (filterName) {\n      // se a string não for vazia, considera como true;\n      filterCards = filterCards.filter(_ref => {\n        let {\n          cardName\n        } = _ref;\n        return cardName.includes(filterName);\n      });\n    }\n\n    if (filterRare !== 'todas') {\n      filterCards = filterCards.filter(_ref2 => {\n        let {\n          cardRare\n        } = _ref2;\n        return cardRare === filterRare;\n      }); // se o filtro por raridade for diferente de todas as cartas, ele atualiza o filterCards, colocando no novo array apenas os cards que possuem a raridade informada, como essa condição aparece depois da filtragem por nome, caso já esteja sendo filtrado algo pelo nome, ele usa como array inicial o que já está filtrado, tornando assim os dois acumulativos.\n    }\n\n    if (filterTrunfo) {\n      filterCards = cardList.filter(_ref3 => {\n        let {\n          cardTrunfo\n        } = _ref3;\n        return cardTrunfo;\n      }); // caso o checkbox de filtro por Super Trunfo seja marcado, ele atualiza o filterCards, usando como array base o array cardList original, por esse motivo, por isso é a última condição, não sendo cumulativa;\n    } // depois de realizar os filtros, o .map será executado para renderizar com o componente Card, os que precisam a lista que precisa ser renderizada;\n\n\n    return /*#__PURE__*/_jsxDEV(\"section\", {\n      children: filterCards.map(card => /*#__PURE__*/_jsxDEV(\"div\", {\n        children: [/*#__PURE__*/_jsxDEV(Card, { ...card\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 42,\n          columnNumber: 13\n        }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n          type: \"button\",\n          \"data-testid\": \"delete-button\",\n          onClick: () => deleteCard(card, card.cardTrunfo),\n          children: \"Excluir\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 45,\n          columnNumber: 13\n        }, this)]\n      }, card.cardName, true, {\n        fileName: _jsxFileName,\n        lineNumber: 41,\n        columnNumber: 11\n      }, this))\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 39,\n      columnNumber: 7\n    }, this);\n  }\n\n}\nFilterList.propTypes = {\n  cardList: PropTypes.array,\n  deteleCard: PropTypes.func,\n  filterName: PropTypes.string,\n  filterRare: PropTypes.string,\n  filterTrunfo: PropTypes.string\n}.isRequired;","map":{"version":3,"sources":["/home/lorismilloni/Repos/top_trumps/src/components/FilterList.jsx"],"names":["React","Component","PropTypes","Card","FilterList","render","cardList","deleteCard","filterName","filterRare","filterTrunfo","props","filterCards","filter","cardName","includes","cardRare","cardTrunfo","map","card","propTypes","array","deteleCard","func","string","isRequired"],"mappings":";AAAA,OAAOA,KAAP,IAAgBC,SAAhB,QAAiC,OAAjC;AACA,OAAOC,SAAP,MAAsB,YAAtB;AACA,OAAOC,IAAP,MAAiB,QAAjB,C,CAEA;AACA;AACA;;;AAEA,eAAe,MAAMC,UAAN,SAAyBH,SAAzB,CAAmC;AAChDI,EAAAA,MAAM,GAAG;AACP,UAAM;AACJC,MAAAA,QADI;AAEJC,MAAAA,UAFI;AAGJC,MAAAA,UAHI;AAIJC,MAAAA,UAJI;AAKJC,MAAAA;AALI,QAMF,KAAKC,KANT;AAQA,QAAIC,WAAW,GAAG,CAAC,GAAGN,QAAJ,CAAlB,CATO,CAUP;AAEA;;AAEA,QAAIE,UAAJ,EAAgB;AACd;AACAI,MAAAA,WAAW,GAAGA,WAAW,CAACC,MAAZ,CAAmB;AAAA,YAAC;AAAEC,UAAAA;AAAF,SAAD;AAAA,eAAkBA,QAAQ,CAACC,QAAT,CAAkBP,UAAlB,CAAlB;AAAA,OAAnB,CAAd;AACD;;AACD,QAAIC,UAAU,KAAK,OAAnB,EAA4B;AAC1BG,MAAAA,WAAW,GAAGA,WAAW,CAACC,MAAZ,CAAmB;AAAA,YAAC;AAAEG,UAAAA;AAAF,SAAD;AAAA,eAAmBA,QAAQ,KAAKP,UAAhC;AAAA,OAAnB,CAAd,CAD0B,CAE1B;AACD;;AACD,QAAIC,YAAJ,EAAkB;AAChBE,MAAAA,WAAW,GAAGN,QAAQ,CAACO,MAAT,CAAgB;AAAA,YAAC;AAAEI,UAAAA;AAAF,SAAD;AAAA,eAAoBA,UAApB;AAAA,OAAhB,CAAd,CADgB,CAEhB;AACD,KAzBM,CA0BP;;;AAEA,wBACE;AAAA,gBACIL,WAAW,CAACM,GAAZ,CAAiBC,IAAD,iBAChB;AAAA,gCACE,QAAC,IAAD,OACOA;AADP;AAAA;AAAA;AAAA;AAAA,gBADF,eAIE;AACE,UAAA,IAAI,EAAC,QADP;AAEE,yBAAY,eAFd;AAGE,UAAA,OAAO,EAAG,MAAMZ,UAAU,CAACY,IAAD,EAAOA,IAAI,CAACF,UAAZ,CAH5B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,gBAJF;AAAA,SAAWE,IAAI,CAACL,QAAhB;AAAA;AAAA;AAAA;AAAA,cADA;AADJ;AAAA;AAAA;AAAA;AAAA,YADF;AAiBD;;AA9C+C;AAiDlDV,UAAU,CAACgB,SAAX,GAAuB;AACrBd,EAAAA,QAAQ,EAAEJ,SAAS,CAACmB,KADC;AAErBC,EAAAA,UAAU,EAAEpB,SAAS,CAACqB,IAFD;AAGrBf,EAAAA,UAAU,EAAEN,SAAS,CAACsB,MAHD;AAIrBf,EAAAA,UAAU,EAAEP,SAAS,CAACsB,MAJD;AAKrBd,EAAAA,YAAY,EAAER,SAAS,CAACsB;AALH,EAMrBC,UANF","sourcesContent":["import React, { Component } from 'react';\nimport PropTypes from 'prop-types';\nimport Card from './Card';\n\n// Requisito 10, 11 e 12 feitos seguindo o PR do Leonardo Vogel, com o objetivo de treinar a implementação da função e quem sabe deixar o joguinho funcional depois. Obrigada Leo.\n// Obrigada Eduardo Bazler por me ajudar a resolver o conflito no requisito, para passar no teste e não imprimir mais duas listas no meu Tryunfo, precisei remover do App o CardList, que continua comitado para consulta, a exibição anterior da lista que eu tinha criado para passar no requisito 8.\n// Agora só a lista com os filtros é exibida na minha página do Tryunfo.\n\nexport default class FilterList extends Component {\n  render() {\n    const {\n      cardList,\n      deleteCard,\n      filterName,\n      filterRare,\n      filterTrunfo,\n    } = this.props;\n\n    let filterCards = [...cardList];\n    // aqui o filtro atualiza o array de cards de acordo com o que foi aplicado, um valor inicial recebe a lista de cartas, para que caso não seja aplicado nenhum filtro, ele exiba todos as cartas;\n\n    // caso exista alguma coisa no input de filtro por nome, ele executa um filter atualizando o próprio filterCards, adicionando ao novo array apenas aqueles cards que tenham no nome o que foi passado no input;\n\n    if (filterName) {\n      // se a string não for vazia, considera como true;\n      filterCards = filterCards.filter(({ cardName }) => cardName.includes(filterName));\n    }\n    if (filterRare !== 'todas') {\n      filterCards = filterCards.filter(({ cardRare }) => (cardRare === filterRare));\n      // se o filtro por raridade for diferente de todas as cartas, ele atualiza o filterCards, colocando no novo array apenas os cards que possuem a raridade informada, como essa condição aparece depois da filtragem por nome, caso já esteja sendo filtrado algo pelo nome, ele usa como array inicial o que já está filtrado, tornando assim os dois acumulativos.\n    }\n    if (filterTrunfo) {\n      filterCards = cardList.filter(({ cardTrunfo }) => cardTrunfo);\n      // caso o checkbox de filtro por Super Trunfo seja marcado, ele atualiza o filterCards, usando como array base o array cardList original, por esse motivo, por isso é a última condição, não sendo cumulativa;\n    }\n    // depois de realizar os filtros, o .map será executado para renderizar com o componente Card, os que precisam a lista que precisa ser renderizada;\n\n    return (\n      <section>\n        { filterCards.map((card) => (\n          <div key={ card.cardName }>\n            <Card\n              { ...card }\n            />\n            <button\n              type=\"button\"\n              data-testid=\"delete-button\"\n              onClick={ () => deleteCard(card, card.cardTrunfo) }\n            >\n              Excluir\n            </button>\n          </div>\n        ))}\n      </section>);\n  }\n}\n\nFilterList.propTypes = {\n  cardList: PropTypes.array,\n  deteleCard: PropTypes.func,\n  filterName: PropTypes.string,\n  filterRare: PropTypes.string,\n  filterTrunfo: PropTypes.string,\n}.isRequired;\n"]},"metadata":{},"sourceType":"module"}